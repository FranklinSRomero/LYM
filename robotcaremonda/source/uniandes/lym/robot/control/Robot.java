/* Robot.java */
/* Generated By:JavaCC: Do not edit this line. Robot.java */
package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
import java.awt.Point;
import java.util.List;

import java.util.HashMap;
import java.lang.String;
import java.util.ArrayList;

public class Robot implements RobotConstants {

        private RobotWorldDec world;
        String salida=new String();

        private HashMap<String, Integer> hashvariables = new HashMap<String, Integer>();
        private static HashMap<String, String> functions = new HashMap<String, String>();
        private Console sistema;


        void setWorld(RobotWorld w) {
                world = (RobotWorldDec) w;
        }

        public static void checkVariableF(Token token){
          String image = token.image.toLowerCase();
                if (!hashvariables.containsKey(image)){
                throw new Error("The variable " + image + " is not defined\nLine: " + token.beginLine + " Column: " + token.beginColumn);
                }
        }

        //funciones primitivas
        public interface Command {
    void execute();}

        //move command
    public class MoveCommand implements Command {
            private final int steps;

            public MoveCommand(int steps) {
                this.steps = steps;
            }

            @Override
            public void execute() {
                world.moveForward(steps, false);}}

        //skip command
    public class SkipCommand implements Command {
            private final int steps;

            public SkipCommand(int steps) {
                this.steps = steps;
            }

            @Override
            public void execute() {
                world.moveForward(steps, true);}}

        //turn command   
        public class TurnCommand implements Command {
            private final int direction;

            public TurnCommand(int direction) {
        this.direction = direction;
    }

            @Override
            public void execute() {
                for (int i = 0; i < direction; i++) {
                        world.turnRight();;
                }}}


        //face command
        public class FaceCommand implements Command {
            private final int direction;

            public FaceCommand(int direction) {
                this.direction = direction;
            }

            @Override
            public void execute() {
                int y;
                int initialfacing;
                        initialfacing = realrobotdirection();
                        y= ajustedirection(direction,initialfacing);
                        TurnCommand turn = new TurnCommand(y);
                        turn.execute();}}

        //put command
        public class PutCommand implements Command {
            private final String objectType;
            private final int quantity;

            public PutCommand(String objectType, int quantity) {
                this.objectType = objectType;
                this.quantity = quantity;
            }

            @Override
            public void execute() {
                switch(objectType) {
                                case ":chips": world.putChips(quantity);break;
                                case ":balloons": world.putBalloons(quantity);break; }
            }
        }

        //pick command
        public class PickCommand implements Command {
            private final String objectType;
            private final int quantity;

            public PickCommand(String objectType, int quantity) {
                this.objectType = objectType;
                this.quantity = quantity;
            }

            @Override
            public void execute() {
                switch(objectType) {
                                case ":chips": world.pickChips(quantity);break;
                                case ":balloons": world.grabBalloons(quantity);break; }
            }
        }

        //move_dir command
        public class Move_dirCommand implements Command {
            private final int steps;
            private final int direction;

            public Move_dirCommand(int steps, int direction) {
                this.steps = steps;
                this.direction = direction;
            }

            @Override
            public void execute() {
                int originaldirection = realrobotdirection();
                        TurnCommand turn = new TurnCommand(direction);
                turn.execute();
                MoveCommand move = new MoveCommand(steps);
                move.execute();
                FaceCommand face = new FaceCommand(originaldirection);
                face.execute();}}

        //run_dir command
        public class Run_dirCommand implements Command {
            private final List<Integer> directions;

            public Run_dirCommand(List<Integer> directions) {
                this.directions = directions;
            }

            @Override
            public void execute() {
                        int direction;
                        for (int i = 0; i < directions.size(); i++) {
            direction = directions.get(i);
            Move_dirCommand Move_dir = new Move_dirCommand(1, direction);
                Move_dir.execute();
                }}}

        //move_face command
        public class Move_faceCommand implements Command {
            private final int steps;
            private final int direction;

            public Move_faceCommand(int steps, int direction) {
                this.steps = steps;
                this.direction = direction;
            }

            @Override
            public void execute() {
                FaceCommand face = new FaceCommand(direction);
                face.execute();
                MoveCommand move = new MoveCommand(steps);
                move.execute();
                }}

        //funciones auxiliares
        int ajustedirection(int direction,int initialfacing) {
          List<Integer> directions = new ArrayList<Integer>();
                if (direction == initialfacing) {return 0; }
        directions.add(0);
        directions.add(3);
        directions.add(2);
        directions.add(1);
        int facing = (directions.get(initialfacing));
        int y = (facing + direction)%4;
        return y;
           }

        int realrobotdirection() {
          int result;
          int initialfacing;
          initialfacing = world.getFacing();
        switch(initialfacing) {
          case 0 : return result=0;
          case 1 : return result=2;
          case 3 : return result=3;
          case 2 : return result=1;
          default: throw new RuntimeException("Unexpected error in get real robotdirection()"); }
        }

/*reglas de produccion*/
  final public 
boolean command(Console sistema) throws ParseException {int x, y;
                Token function;
                salida = new String();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ARM:
    case MOVE:
    case FSKIP:
    case PUT:
    case PICK:
    case TURN:
    case FACE:
    case MOVE_DIR:
    case RUN_DIRS:
    case MOVE_FACE:
    case NULL:
    case IF:
    case WHILE:
    case FOR:
    case DEFVAR:
    case EQUALS:
    case DEFUN:
    case IDENTIFIER:{
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ARM:{
          block(sistema);
          break;
          }
        case MOVE:
        case FSKIP:
        case PUT:
        case PICK:
        case TURN:
        case FACE:
        case MOVE_DIR:
        case RUN_DIRS:
        case MOVE_FACE:
        case NULL:
        case EQUALS:{
          primitivefuctions(sistema);
          break;
          }
        case DEFVAR:{
          jj_consume_token(DEFVAR);
          defvar();
          break;
          }
        case DEFUN:{
          jj_consume_token(DEFUN);
          defun();
          break;
          }
        case IF:
        case WHILE:
        case FOR:{
          controlStructures(sistema);
          break;
          }
        case IDENTIFIER:{
          function = jj_consume_token(IDENTIFIER);
llamarFuncion(function);
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
try {Thread.sleep(900);}
                catch (InterruptedException e)
                {System.err.format("IOException: %s%n", e);}
            sistema.printOutput(salida);
                {if ("" != null) return true;}
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ARM:
        case MOVE:
        case FSKIP:
        case PUT:
        case PICK:
        case TURN:
        case FACE:
        case MOVE_DIR:
        case RUN_DIRS:
        case MOVE_FACE:
        case NULL:
        case IF:
        case WHILE:
        case FOR:
        case DEFVAR:
        case EQUALS:
        case DEFUN:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
      }
      break;
      }
    case 0:{
      jj_consume_token(0);
hashvariables.clear(); functions.clear(); {if ("" != null) return false;}
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  final public void block(Console sistema) throws ParseException {
    jj_consume_token(ARM);
    command(sistema);
    jj_consume_token(51);
}

  final public void defvar() throws ParseException {Token variable; int value;
    variable = jj_consume_token(IDENTIFIER);
    value = num();
hashvariables.put(variable.image, value);
}

// Método para llamar a una función definida
  final public 
void defun() throws ParseException, ParseException {Token functionName;
    functionName = jj_consume_token(IDENTIFIER);
if (functions.containsKey(functionName.image.toLowerCase())) {
            {if (true) throw new ParseException("Function " + functionName.image + " already defined.");}
        }
        // Almacenar el nombre de la función
        String functionNameLower = functionName.image.toLowerCase();
        functions.put(functionNameLower, functionNameLower);

        // Almacenar las variables locales
        localVariables.clear(); // Limpiar variables locales anteriores

    jj_consume_token(ARM);
    parameters();
    jj_consume_token(51);
    jj_consume_token(52);
    body();
    jj_consume_token(53);
}

  final public void parameters() throws ParseException, ParseException {Token parameter;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      parameter = jj_consume_token(IDENTIFIER);
// Verificar si el parámetro ya está definido
            String paramName = parameter.image.toLowerCase();
            if (localVariables.containsKey(paramName)) {
                {if (true) throw new ParseException("Parameter " + paramName + " already defined.");}
            }
            // Almacenar el parámetro en el HashMap de variables locales
            localVariables.put(paramName, null); // Inicialmente sin valor

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 54:{
        jj_consume_token(54);
        parameters();
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      ;
    }
}

  final public void body() throws ParseException, ParseException {List<Command> commands = new ArrayList<>();
    jj_consume_token(ARM);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ARM:{
        ;
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      statisblock();
commands.addAll(popCommands());
    }
    jj_consume_token(51);
functionBody = commands;
}

  final public void primitivefuctions(Console sistema) throws ParseException {Token action;
                    int n, x, y, value;
                    Token item;
                    Token variable;
                    int direction;
                    List<Integer> directions = new ArrayList<Integer>();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALS:{
      jj_consume_token(EQUALS);
      variable = jj_consume_token(IDENTIFIER);
checkVariableF(variable);
      value = num();
hashvariables.put(variable.image, value);
      break;
      }
    case MOVE:{
      jj_consume_token(MOVE);
      n = globalvariable();
MoveCommand move = new MoveCommand(n);
                move.execute();
      break;
      }
    case FSKIP:{
      jj_consume_token(FSKIP);
      n = globalvariable();
SkipCommand skip = new SkipCommand(n);
                skip.execute();
      break;
      }
    case TURN:{
      jj_consume_token(TURN);
      n = Direcionrobot();
TurnCommand turn = new TurnCommand(n);
                turn.execute();
      break;
      }
    case FACE:{
      jj_consume_token(FACE);
      direction = direccionmundo();
FaceCommand face = new FaceCommand(direction);
                face.execute();
      break;
      }
    case PUT:{
      jj_consume_token(PUT);
      variable = jj_consume_token(X_OBJECT);
      n = globalvariable();
PutCommand put = new PutCommand(variable.image,n);
                put.execute();
      break;
      }
    case PICK:{
      jj_consume_token(PICK);
      variable = jj_consume_token(X_OBJECT);
      n = globalvariable();
PickCommand pick = new PickCommand(variable.image,n);
                pick.execute();
      break;
      }
    case MOVE_DIR:{
      jj_consume_token(MOVE_DIR);
      n = globalvariable();
      direction = Direcionrobot();
Move_dirCommand Move_dir = new Move_dirCommand(n, direction);
                Move_dir.execute();
      break;
      }
    case RUN_DIRS:{
      jj_consume_token(RUN_DIRS);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEFT:
        case RIGHT:
        case AROUND:
        case BACK:
        case FRONT:{
          ;
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
        value = Direcionrobot();
directions.add(value);
      }
Run_dirCommand Run_dir = new Run_dirCommand(directions);
                Run_dir.execute();
      break;
      }
    case MOVE_FACE:{
      jj_consume_token(MOVE_FACE);
      n = globalvariable();
      direction = direccionmundo();
Move_faceCommand Move_dir = new Move_faceCommand(n,direction);
                Move_dir.execute();
      break;
      }
    case NULL:{
      jj_consume_token(NULL);
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

  final public void controlStructures(Console sistema) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IF:{
      jj_consume_token(IF);
      iffuntion(sistema);
      break;
      }
    case WHILE:{
      jj_consume_token(WHILE);
      whilefuntion();
      break;
      }
    case FOR:{
      jj_consume_token(FOR);
      forfuntion(sistema);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

  final public List<Command> statismegablock() throws ParseException {List<Command> comandos = new ArrayList<Command>();
        Token tok;
    tok = jj_consume_token(ARM);
if (tok.next.image != "(") {comandos=statisblock();}
         else {comandos=statiscommands();}
{if ("" != null) return comandos;}
    throw new Error("Missing return statement in function");
}

  final public List<Command> statiscommands() throws ParseException {List<Command> comandos = new ArrayList<Command>();
        List<Command> tempi = new ArrayList<Command>();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ARM:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      jj_consume_token(ARM);
      tempi = statisblock();
      jj_consume_token(51);
comandos.addAll(tempi);
    }
    jj_consume_token(51);
{if ("" != null) return comandos;}
    throw new Error("Missing return statement in function");
}

  final public List<Command> statisblock() throws ParseException {List<Command> comandos = new ArrayList<Command>();

                        int n, x, y, value;
                    Token item;
                    Token variable;
                    int direction;
                    List<Integer> directions = new ArrayList<Integer>();
    jj_consume_token(ARM);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALS:{
      jj_consume_token(EQUALS);
      variable = jj_consume_token(IDENTIFIER);
checkVariableF(variable);
      value = num();
hashvariables.put(variable.image, value);
      break;
      }
    case MOVE:{
      jj_consume_token(MOVE);
      n = globalvariable();
MoveCommand move = new MoveCommand(n);
                        comandos.add(move);
      break;
      }
    case FSKIP:{
      jj_consume_token(FSKIP);
      n = globalvariable();
SkipCommand skip = new SkipCommand(n);
                comandos.add(skip);
      break;
      }
    case TURN:{
      jj_consume_token(TURN);
      n = Direcionrobot();
TurnCommand turn = new TurnCommand(n);
                comandos.add(turn);
      break;
      }
    case FACE:{
      jj_consume_token(FACE);
      direction = direccionmundo();
FaceCommand face = new FaceCommand(direction);
                comandos.add(face);
      break;
      }
    case PUT:{
      jj_consume_token(PUT);
      variable = jj_consume_token(X_OBJECT);
      n = globalvariable();
PutCommand put = new PutCommand(variable.image,n);
                comandos.add(put);
      break;
      }
    case PICK:{
      jj_consume_token(PICK);
      variable = jj_consume_token(X_OBJECT);
      n = globalvariable();
PickCommand pick = new PickCommand(variable.image,n);
                comandos.add(pick);
      break;
      }
    case MOVE_DIR:{
      jj_consume_token(MOVE_DIR);
      n = globalvariable();
      direction = Direcionrobot();
Move_dirCommand Move_dir = new Move_dirCommand(n, direction);
                comandos.add(Move_dir);
      break;
      }
    case RUN_DIRS:{
      jj_consume_token(RUN_DIRS);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEFT:
        case RIGHT:
        case AROUND:
        case BACK:
        case FRONT:{
          ;
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
        value = Direcionrobot();
directions.add(value);
      }
Run_dirCommand Run_dir = new Run_dirCommand(directions);
                comandos.add(Run_dir);
      break;
      }
    case MOVE_FACE:{
      jj_consume_token(MOVE_FACE);
      n = globalvariable();
      direction = direccionmundo();
Move_faceCommand Move_dir = new Move_faceCommand(n,direction);
                comandos.add(Move_dir);
      break;
      }
    case NULL:{
      jj_consume_token(NULL);
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(51);
{if ("" != null) return comandos;}
    throw new Error("Missing return statement in function");
}

  final public void executecommands(List<Command> comandos) throws ParseException {
for (Command command : comandos) {
            command.execute();
        }
}

  final public void iffuntion(Console sistema) throws ParseException {boolean boolresult;
        List<Command> comandostrue;List<Command> comandosfalse;

    jj_consume_token(ARM);
    boolresult = evaluatecondition();
    jj_consume_token(51);
comandostrue = statisblock();
comandosfalse = statisblock();
if (boolresult) {
                    executecommands(comandostrue); }
if (!boolresult) {
                    executecommands(comandosfalse); }
}

  final public boolean evaluatecondition() throws ParseException {boolean result = false;int n, x, y, value;
                    Token item;
                    Token variable;
                    int direction;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FACING:{
      jj_consume_token(FACING);
      direction = direccionmundo();
result = (direction == realrobotdirection());
      break;
      }
    case BLOCKED:{
      jj_consume_token(BLOCKED);
int realdirection = realrobotdirection();
        switch (realdirection){
                 case 0 : result= world.isUp();break;
                 case 2 : result= world.isDown();break;
                 case 3 : result= world.isLeft();break;
                 case 1 : result= world.isRight();break;
                 default : {if (true) throw new IllegalArgumentException("Invalid facing direction: " + realdirection);}}
      break;
      }
    case CAN_PUT:{
      jj_consume_token(CAN_PUT);
      item = jj_consume_token(X_OBJECT);
      n = globalvariable();
result = (item.image.equals(":chips") ? n <= world.getMyChips() : n <= world.getMyBalloons());
      break;
      }
    case CAN_PICK:{
      jj_consume_token(CAN_PICK);
      item = jj_consume_token(X_OBJECT);
      n = globalvariable();
result = (item.image.equals(":chips") ? n >= world.chipsToPick() : n >= world.getMyBalloons());
      break;
      }
    case CAN_MOVE:{
      jj_consume_token(CAN_MOVE);
      direction = direccionmundo();
switch (direction){
                 case 0 : result= !world.isUp();break;
                 case 2 : result= !world.isDown();break;
                 case 3 : result= !world.isLeft();break;
                 case 1 : result= !world.isRight();break;
                 default : {if (true) throw new IllegalArgumentException("Invalid direction: " + direction);}
                      }
      break;
      }
    case IS_ZERO:{
      jj_consume_token(IS_ZERO);
      n = globalvariable();
result = (n == 0);
      break;
      }
    case NOT:{
      jj_consume_token(NOT);
      jj_consume_token(ARM);
result = !evaluatecondition();
      jj_consume_token(51);
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
}

  final public void whilefuntion() throws ParseException {
    jj_consume_token(ARM);

}

  final public void forfuntion(Console sistema) throws ParseException {int repeticiones;Token source;
    repeticiones = globalvariable();

}

  final public int Direcionrobot() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FRONT:{
      jj_consume_token(FRONT);
{if ("" != null) return 0;}
      break;
      }
    case BACK:{
      jj_consume_token(BACK);
{if ("" != null) return 2;}
      break;
      }
    case LEFT:{
      jj_consume_token(LEFT);
{if ("" != null) return 3;}
      break;
      }
    case RIGHT:{
      jj_consume_token(RIGHT);
{if ("" != null) return 1;}
      break;
      }
    case AROUND:{
      jj_consume_token(AROUND);
{if ("" != null) return 2;}
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  final public int direccionmundo() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NORTH:{
      jj_consume_token(NORTH);
{if ("" != null) return 0;}
      break;
      }
    case SOUTH:{
      jj_consume_token(SOUTH);
{if ("" != null) return 2;}
      break;
      }
    case WEST:{
      jj_consume_token(WEST);
{if ("" != null) return 1;}
      break;
      }
    case EAST:{
      jj_consume_token(EAST);
{if ("" != null) return 3;}
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  final public int globalvariable() throws ParseException {int value;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM:{
      jj_consume_token(NUM);
value = Integer.parseInt(token.image);
      break;
      }
    case IDENTIFIER:{
      token = jj_consume_token(IDENTIFIER);
String varName = token.image;
                   if (hashvariables.containsKey(varName)) {
                       value = hashvariables.get(varName);
                   } else {
                       {if (true) throw new ParseException("Variable " + varName + " not found.");}}
      break;
      }
    case DIM:
    case MY_X_POS:
    case MY_Y_POS:
    case MY_CHIPS:
    case MY_BALLOONS:
    case BALLOONS_HERE:
    case CHIPS_HERE:
    case SPACES:{
      value = GameConstants();
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
}

  final public int GameConstants() throws ParseException {int value = 0;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DIM:{
      jj_consume_token(DIM);
value = world.getN();
      break;
      }
    case MY_X_POS:{
      jj_consume_token(MY_X_POS);
value = world.getPosition().x;
      break;
      }
    case MY_Y_POS:{
      jj_consume_token(MY_Y_POS);
value = world.getPosition().y;
      break;
      }
    case MY_CHIPS:{
      jj_consume_token(MY_CHIPS);
value = world.getMyChips();
      break;
      }
    case MY_BALLOONS:{
      jj_consume_token(MY_BALLOONS);
value = world.getMyBalloons();
      break;
      }
    case BALLOONS_HERE:{
      jj_consume_token(BALLOONS_HERE);
value = world.countBalloons();
      break;
      }
    case CHIPS_HERE:{
      jj_consume_token(CHIPS_HERE);
value = world.chipsToPick();
      break;
      }
    case SPACES:{
      jj_consume_token(SPACES);
value = world.freeSpacesForChips();
{if ("" != null) return value;}
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/**
	 * Unsigned decimal number
	 * @return the corresponding value of the string
	 * @error  corresponding value is too large
	 */
  final public 
        int num() throws ParseException, Error {Token variable;
                int value;
                int total=1;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUM:{
      jj_consume_token(NUM);
try
                        {
                                total = Integer.parseInt(token.image);
                        }
                        catch (NumberFormatException ee)
                        {
                                {if (true) throw new Error("Number out of bounds: "+token.image+" !!");}
                        }
                        {if ("" != null) return total;}
      break;
      }
    case IDENTIFIER:{
      variable = jj_consume_token(IDENTIFIER);
try {
                                value = hashvariables.get(variable.image);
                        }
                        catch (Exception e)
                        {
                                {if (true) throw new Error("variable no inicializada: "+token.image+" !!");}
                        }
                   {if ("" != null) return value;}
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  /** Generated Token Manager. */
  public RobotTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[18];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x3fffe0,0x3fffe0,0x3fffe1,0x0,0x0,0x20,0x7c00000,0x10ffc0,0x70000,0x20,0x7c00000,0x10ffc0,0x0,0x7c00000,0x78000000,0x0,0x0,0x0,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x8000,0x8000,0x8000,0x400000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f,0x0,0x0,0x1ff80,0x7f80,0x18000,};
	}

  /** Constructor with InputStream. */
  public Robot(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Robot(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new RobotTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Robot(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new RobotTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new RobotTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Robot(RobotTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(RobotTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 18; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[55];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 18; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 55; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
